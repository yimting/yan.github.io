<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#B0E0E6">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/Head.jpg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Head.jpg?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.svg?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#B0E0E6">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="摘要：一些面试的总结，不断更新……">
<meta name="keywords" content="Code,Java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题总结">
<meta property="og:url" content="http://yimting.github.io/2019/05/03/面试题总结/index.html">
<meta property="og:site_name" content="Baki&#39;Blog">
<meta property="og:description" content="摘要：一些面试的总结，不断更新……">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yimting.github.io/2019/05/03/面试题总结/Servlet.jpg">
<meta property="og:image" content="http://yimting.github.io/2019/05/03/面试题总结/001.jpg">
<meta property="og:updated_time" content="2019-06-02T07:13:10.520Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题总结">
<meta name="twitter:description" content="摘要：一些面试的总结，不断更新……">
<meta name="twitter:image" content="http://yimting.github.io/2019/05/03/面试题总结/Servlet.jpg">





  
  
  <link rel="canonical" href="http://yimting.github.io/2019/05/03/面试题总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试题总结 | Baki'Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Baki'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">yimting@aliyun.com</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yimting.github.io/2019/05/03/面试题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yimting@aliyun.com">
      <meta itemprop="description" content="路漫漫其修远兮">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Baki'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试题总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-03 22:50:47" itemprop="dateCreated datePublished" datetime="2019-05-03T22:50:47+08:00">2019-05-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-02 15:13:10" itemprop="dateModified" datetime="2019-06-02T15:13:10+08:00">2019-06-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Learn/" itemprop="url" rel="index"><span itemprop="name">Learn</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>摘要：一些面试的总结，不断更新……<a id="more"></a></p>
</blockquote>
<ol>
<li><p><strong>写出几种Java单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------静态内部类实现-------------------*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 实现单例的模式的静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewSingleton</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 获取单例的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * 内部类 NewSingleton 的静态变量 INSTANCE，这个变量是我们需要的那个单例，即外部类 NewSingleton 的对象，就是那个我们需要的唯一的对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当我们调用 Singleton.getInstance() 时，内部类 NewSingleton 才会初始化，静态变量 INSTANCE 被创建出来。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  NewSingleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------饿汉式实现-------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton newSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getNewSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------------懒汉实现---------------------*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p><strong><a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">Java HashMap 实现原理</a></strong></p>
<blockquote>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
</blockquote>
<p>!(盗图)[<a href="https://dl.iteye.com/upload/picture/pic/63364/042032ea-6f15-3428-bfb4-b3b1460769a7.jpg" target="_blank" rel="noopener">https://dl.iteye.com/upload/picture/pic/63364/042032ea-6f15-3428-bfb4-b3b1460769a7.jpg</a>]</p>
<blockquote>
<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>
</blockquote>
<blockquote>
<p>存储: (  HashMap允许存放null键和null值。)</p>
<p>根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p>读取：</p>
<p>从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
</blockquote>
<blockquote>
<p><strong>总结：HashMap的实现原理：</strong></p>
<ol>
<li><strong>利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</strong></li>
<li><strong>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</strong></li>
<li><strong>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</strong></li>
<li><strong>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</strong></li>
</ol>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p><strong>Java Servlet<a href="https://www.runoob.com/servlet/servlet-life-cycle.html" target="_blank" rel="noopener">生命周期</a>和每个过程</strong></p>
<ul>
<li>架构图：</li>
</ul>
<p><img src="/2019/05/03/面试题总结/Servlet.jpg" alt="Severlet"></p>
</li>
<li><p><strong>使用shell，编程实现 a.txt 文件中有多行记录，查找包含“Available do” 的记录，如果记录超过10条，则输出符合条件的记录</strong></p>
</li>
<li><p><strong>HDFS上传文件命令，文件上传流程</strong></p>
<blockquote>
<p>hdfs dfs -put ‘FilePath’</p>
<ol>
<li>客户端申请上传文件，namenode检查元数据中是否存在该文件，如果没有，返会信息可以上传</li>
<li>客户端收到可以上传的信息，将文件切成块（Block 128M），切成 x 块，除去最后一块大小不一定，其他块大小一致</li>
<li>客户端拿到 第一个块 ，向 namenode 提交上传信息，namenode 将应该上传到哪几个的 datanode地址 返回给客户端。</li>
<li>客户端收到 datanode 地址，进行 socket 流的方式进行上传到 距离客户端最近的 datanode 中， 之后这台 datanode 节点会进行 block1 进行备份，将该块进行复制到其他的 datanode 中 </li>
<li>当 datanode 所有块，传输完毕之后，会返回客户端 block1 上传成功。</li>
<li>循环以上 block 上传的过程</li>
</ol>
</blockquote>
</li>
<li><p><strong>Spark reduceByKey 和 groupByKey 实现原理，有什么区别。</strong></p>
<blockquote>
<ol>
<li>reduceByKey(func[,num Tasks])</li>
</ol>
<p>当键值相同的键值对(K,V)数据集调用此方法，他们的键对应的值会根据指定的函数(func)进行聚合，而键值(V,V)也进行合并，返回键值(V)，最终返回一个键值对(K,V)数据集。当然，你也可以通过可选参数num Tasks，指定任务执行的次数。</p>
<ol start="2">
<li>groupByKey([num Tasks])</li>
</ol>
<p>当键值对(K,V)数据集调用此方法，会返回一个键值对(K, Iterable)数据集，其中键值是原来键值组成的、可遍历的集合。我们也可以通过num Tasks参数指定任务执行的次数。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="type">Array</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>, <span class="string">"three"</span>)</span><br><span class="line"><span class="keyword">val</span> wordPairsRDD = sc.parallelize(words).map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> wordCountsWithReduce = wordPairsRDD.reduceByKey(_ + _).collect()</span><br><span class="line"><span class="keyword">val</span> wordCountsWithGroup = wordPairsRDD.groupByKey().map(t =&gt; (t._1, t._2.sum)).collect()</span><br><span class="line"><span class="comment">//尽管两个函数都能得到正确的结果，但是reduceByKey更适合作用在较大的数据集上，因为在对数据进行转换时，Spark知道在每个分区上可以对这些键值进行合并输出。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p><strong>Spark任务有几种提交部署模式，每种模式的特点是什么。</strong></p>
</li>
<li><p><strong>有一个存储 Int 型的数字文件，大小为2G ， 设计一个查询服务，用户输入一个数字返回是否在文件中出现过，列出实现思路</strong></p>
</li>
<li><p><img src="/2019/05/03/面试题总结/001.jpg" alt="001"></p>
</li>
<li><p><strong>Implement int sqrt(int x).Compute and return the square root of x.  求一个整数的完全平方数，但返回的是Int。</strong> ( linkCode 39题目 )</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Text &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="keyword">int</span>.MAXVALUE)&#123;</span><br><span class="line">            x = <span class="keyword">int</span>.MAXVALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> half=<span class="keyword">int</span>.MAXVALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = half;i &gt;= <span class="number">1</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i * i == x )&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i * i &lt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="12">
<li><strong>编程题：写一段Java 代码压缩字符串。比如输入是： AAAAABBBCCCD 输出是： A5B3C3D</strong></li>
<li><strong>使用 Shell 编写一个 WordCount</strong></li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat FILE_NAME.txt | tr -s <span class="string">' '</span> <span class="string">'\n'</span> | sort | uniq -c |  sort -r | awk <span class="string">'&#123; print $2, $1 &#125;'</span></span><br></pre></td></tr></table></figure>
<ol start="14">
<li><p><strong>Redis,RDBM,HBase,Hive 之间的区别</strong></p>
<blockquote>
<p>Redis是k-v型数据库，目标是做高效的分布式缓存。数据一般不实时落地。也不适合做存储和分析。</p>
<p>HBase是列式数据库，BigTable的一种实现，目标是高效存储大量数据，支持列压缩，行事务。</p>
<p>Hive是数据仓库，并不是一个具体的数据库的存在。是为了简化编写MR程序而生的。</p>
<p>Redis为内存型KV系统，处理的数据量要小于HBase</p>
<p>Redis的还在于它不像HBase只支持简单的字符串，还支持集合set，有序集合zset和哈希hash</p>
</blockquote>
</li>
<li><p><strong>RDD，DS，DF之间的区别与联系，内部实现，相互转换</strong></p>
<blockquote>
<p><strong>共性</strong>：</p>
<p>​    RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利</p>
<p>​    三者都有惰性机制，在进行创建、转换，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算。</p>
<p>​    三者都会根据spark的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出</p>
<p>​    三者都有partition的概念</p>
<p>​    三种方式存在着许多相同的函数操作</p>
<p><strong>区别</strong> :</p>
<p>​    </p>
<ul>
<li>RDD :</li>
<li>RDD一般使用sparkCore下面的算子对数据集进行的处理</li>
<li>RDD不支持sparksql操作</li>
<li>DataFrame :</li>
<li>与RDD和Dataset不同，DataFrame每一行的类型固定为Row，只有通过解析才能获取各个字段的值</li>
<li>DataFrame与Dataset支持一些特别方便的保存方式，比如保存成csv</li>
<li>DataFrame与Dataset均支持sparksql的操作，比如select，groupby之类，还能注册临时表/视窗</li>
<li>DataSet：</li>
<li>DataFrame也可以叫Dataset[Row],每一行的类型是Row。</li>
<li>而Dataset中，每一行是什么类型是不一定的，尤其实在自定义了case class了之后</li>
</ul>
<p><strong>转换</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//DataFrame/Dataset转RDD：</span></span><br><span class="line">&gt; <span class="comment">//这个转换很简单</span></span><br><span class="line">&gt; <span class="keyword">val</span> rdd1=testDF.rdd</span><br><span class="line">&gt; <span class="keyword">val</span> rdd2=testDS.rdd</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//RDD转DataFrame：</span></span><br><span class="line">&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line">&gt; <span class="keyword">val</span> testDF = rdd.map &#123;line=&gt;</span><br><span class="line">&gt;       (line._1,line._2)</span><br><span class="line">&gt;     &#125;.toDF(<span class="string">"col1"</span>,<span class="string">"col2"</span>)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//一般用元组把一行的数据写在一起，然后在toDF中指定字段名</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//RDD转Dataset：</span></span><br><span class="line">&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line">&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Coltest</span>(<span class="params">col1:<span class="type">String</span>,col2:<span class="type">Int</span></span>)<span class="keyword">extends</span> <span class="title">Serializable</span> <span class="title">//定义字段名和类型</span></span></span><br><span class="line"><span class="class"><span class="title">&gt;</span> <span class="title">val</span> <span class="title">testDS</span> </span>= rdd.map &#123;line=&gt;</span><br><span class="line">&gt;       <span class="type">Coltest</span>(line._1,line._2)</span><br><span class="line">&gt;     &#125;.toDS</span><br><span class="line">&gt; <span class="comment">//可以注意到，定义每一行的类型（case class）时，已经给出了字段名和类型，后面只要往case class里面添加值即可</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//Dataset转DataFrame：</span></span><br><span class="line">&gt; <span class="comment">//这个也很简单，因为只是把case class封装成Row</span></span><br><span class="line">&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line">&gt; <span class="keyword">val</span> testDF = testDS.toDF</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//DataFrame转Dataset：</span></span><br><span class="line">&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line">&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Coltest</span>(<span class="params">col1:<span class="type">String</span>,col2:<span class="type">Int</span></span>)<span class="keyword">extends</span> <span class="title">Serializable</span> <span class="title">//定义字段名和类型</span></span></span><br><span class="line"><span class="class"><span class="title">&gt;</span> <span class="title">val</span> <span class="title">testDS</span> </span>= testDF.as[<span class="type">Coltest</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
</li>
<li><p><strong>设计日志收集分析系统</strong></p>
</li>
</ol>
<blockquote>
<p>（日志分布在各个业务系统中，我们需要对当天的日志进行实时的汇总统计，同时又能按天查询历史的汇总数据，可以围绕PV、UV、IP等指标进行阐述）</p>
</blockquote>
<blockquote>
<ol>
<li>通过flume将不同系统的日志收集到kafka中</li>
<li><p>通过storm实时的处理PV、UV、IP</p>
</li>
<li><p>通过kafka的consumer将日志生产到HBASE中。</p>
</li>
<li><p>通过离线的MapReduce或者Hive，处理HBASE中的数据</p>
</li>
</ol>
</blockquote>
<ol start="17">
<li><strong>给定a、b两个文件，各存放50亿个url，每个url占用64字节，内存限制是4G，找出a、b两个文件共同的url</strong></li>
</ol>
<blockquote>
<ol>
<li><p>可以估计每个文件的大小为50亿×64=298G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
</li>
<li><p>将文件存储到HDFS中，这样每个文件为64M或者是128M</p>
</li>
<li><p>分别对两个文件的url进行去重、排序输出，这样能排除a文件中相同的url，b文件也一样</p>
</li>
<li><p>对a、b两个文件处理后的结果进行wordcount，并且在reduce中判断单词个数，个数为2的时候输出，这样就找到了a、b文件中的相同url。</p>
</li>
<li>此计算步骤中的每一步加载到内存中的文件大小都不会超过64M，远远小于4G。</li>
</ol>
</blockquote>
<ol start="18">
<li><strong>实时数据统计会用到哪些技术？他们各自的应用场景和区别是什么？</strong></li>
</ol>
<blockquote>
<p>Flume : 日志收集系统， 主要是将日志文件收集到存储系统中，</p>
<p>Kafka : 消息队列系统，进行消息的缓存和系统与系统之间的解耦</p>
<p>SparkStreaming : 进行实时计算框架 ， 实现流计算</p>
</blockquote>
<ol start="19">
<li><strong>mapred找共同好友，数据格式如下</strong></li>
</ol>
<blockquote>
<p><strong>A B C D E F</strong></p>
<p><strong>B A C D E</strong></p>
<p><strong>C A B E</strong></p>
<p><strong>D A B E</strong></p>
<p><strong>E A B C D</strong></p>
<p><strong>F A</strong></p>
<p><strong>第一个字母是本人，其他是他的朋友，找出有共同好友的人，和共同好友是谁</strong></p>
<p> 思路：例如A，他的朋友是B\C\D\E\F\，那么BC的共同朋友就是A。所以将BC作为key，将A作为value，在map端输出即可！其他的朋友循环处理。</p>
</blockquote>
<ol start="20">
<li><strong>Hive 中的 left join / right join 区别</strong></li>
<li><strong>hive中有没有遇到数据倾斜？是怎么解决的？</strong></li>
</ol>
<blockquote>
<p> 由于key分布不均衡造成的数据往一个方向偏移的现象。</p>
<p> 本身的数据倾斜。</p>
<p> join语句容易造成</p>
<p> count（distinct col）</p>
<p> group by </p>
<p> 解决：</p>
<p> set hive.map.aggr=true</p>
<p> set hive.groupby.skewindata=false/true(建议开启)</p>
<p> set hive.optimize.skewjoin=false/true</p>
</blockquote>
<ol start="20">
<li><p><strong>MapReduce的Shuffle过程</strong></p>
<p> 画图，画图，画图</p>
<p> 1.maptask执行，outputcollect收集maptask的输出数据，将数据写入环形缓冲区中，记录起始偏移量</p>
<p> 2.环形缓冲区默认大小为100M，当数据达到80M时，记录终止偏移量。</p>
<p> 3.启动spiller溢出器，将数据进行分区（默认分组根据key的hash值%reduce数量进行分区），分区内进行快速排序</p>
<p> 4.分区，排序结束后，将数据刷写到磁盘（这个过程中，maptask输出的数据写入剩余20%环形缓冲区，同样需要记录起始偏移量）</p>
<p> 5.maptask将形成的多个小文件做归并排序合并成一个大文件</p>
<p> 6.当有一个maptask执行完成后，appMaster申请资源，启动reducetask</p>
<p> 7.reducetask到运行完成maptask的机器上拉取属于自己分区的数据</p>
<p> 8.reducetask将拉取过来的数据进行merge操作，归并排序数据，将数据按相同key“分组”，每组数据调用一次reduce（）方法</p>
<p> 9.执行reduce逻辑，将结果输出到文件</p>
</li>
<li><p><strong>Shffule过程中排序用的什么算法</strong></p>
<blockquote>
<ol>
<li>溢出过程的分区排序采用快排算法</li>
<li>merge过程中采用归并排序算法</li>
</ol>
</blockquote>
</li>
<li><p><strong>如果Reduce个数和分区数不一致时，会发生什么</strong></p>
<blockquote>
<p> 1、如果reduce个数大于分区数，多的reduce将会生成空的输出文件</p>
<p> 2、如果reduce个数小于分区数，将会报错，数据找不到分区。</p>
<p>​    可以自定义Partitioner类，在getPartition中采用分区数%reduce个数进行处理。</p>
</blockquote>
</li>
<li><p><strong>使用过Hive解析JSON串么</strong></p>
<p> 采用jsonSerde解析数据，也可以自动以UDF处理</p>
</li>
<li><p><strong>Hbase 与 Mysql 的区别 ? </strong></p>
</li>
</ol>
<blockquote>
<p>首先从定义说起：</p>
<ol>
<li>hbase 是一个 基于HDFS ，支持海量数据存储的列式数据库，而且是分布式的Nosql。支持主从架构，事务，但是不支持二级索引，不支持SQL</li>
<li>Mysql 是一个关系型数据库，支持sql ， 面型 OLTP , 支持事务，支持二级索引，主从架构，等等，但是不适用于海量数据的存储，即使拥有Mysql集群</li>
</ol>
<p>其次从存储方式说起：</p>
<ol>
<li>Hbase 是一个面向列的Nosql 数据库 ， 比较适合 OLAP [^2]，采用了列簇的方式比较大的平衡 OLAP / OLTP ， 支持水平扩展，如果恰巧数据量比较大，而且对于性能，事务不是特别高，Hbase 是个不错的选择</li>
<li>Mysql 行式存储比较适合OLTP[^1]一类的业务，</li>
</ol>
</blockquote>
<ol start="25">
<li><p><strong>hbase里的热点问题遇到过么？怎么解决的？</strong></p>
<p> 一、出现热点问题原因</p>
<p> 1、hbase的中的数据是按照字典序排序的，当大量连续的rowkey集中写在个别的region，各个region之间数据分布不均衡；</p>
<p> 2、创建表时没有提前预分区，创建的表默认只有一个region，大量的数据写入当前region；</p>
<p> 3、创建表已经提前预分区，但是设计的rowkey没有规律可循，设计的rowkey应该由regionNo+messageId组成。</p>
<blockquote>
<p> 如何解决热点问题? </p>
<p> 设计可以让数据分布均匀的rowkey，与nosql数据库们一样，rowkey是用来检索记录的主键。访问hbase table中的行，rowkey?可以是任意字符串(最大长度 是 64KB，实际应用中长度一般为 10-100bytes)，在hbase内部，rowkey保存为字节数组，存储时，数据按照rowkey的字典序排序存储。</p>
<p> 1、第一种设计rowkey方式：随机数+messageId，如果想让最近的数据快速get到，可以将时间戳加上这种设计的rowkey可以解决热点问题，但是要建立关联表，比如将rowkey保存到数据库或者nosql数据库中，因为前面的regionNo是随机的，不知道对应数据在hbase的rowkey是多少；同一批数据，因为这个regionNo是随机的，所以要到多个region中get数据，不能使用startkey和endkey去get数据。</p>
<p> 2、第二种设计rowkey的方式：通过messageId映射regionNo，这样既可以让数据均匀分布到各个region中，同时可以根据startkey和endkey可以get到同一批数据messageId映射regionNo，使用一致性hash算法解决</p>
</blockquote>
</li>
<li><p><strong>你自定义的UDAF函数都实现了哪些功能？</strong></p>
<p>关于UDAF:</p>
<blockquote>
<ol>
<li><p>UDAF是Hive中用户自定义的聚集函数。如：Hive中内置的UDAF聚集函数包括sum和count。</p>
</li>
<li><p>聚合多行数据，然后返回单一值。</p>
</li>
<li>Hive自带的绝大多数聚合函数，大多数情况下都能满足业务需求，不能满足业务的是极个别的情形。</li>
</ol>
</blockquote>
</li>
</ol>
<pre><code>使用UDAF函数实现了：

&gt; 1. 类似于要合并相同的field对应的值，如：{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;}，若结果集中存在，则不用处理，不存在，则加入。该需求，可以使用hive自带的collect_set内置函数，该函数用于计算去重后的元素的数组。
&gt; 2. 有A、B、C三列，按A列进行聚合，求出C列聚合后的最小值和最大值各自对应的B列值。这个需求用hql和内建函数也可完成，但是比较繁琐，会解析成几个MR进行执行，如果自定义UDAF便可只利用一个MR完成任务。 
</code></pre><ol start="27">
<li><strong>交给你一个100G 大小的Log File，其中存放着IP地址，如何从中获取次数最多的IP地址？</strong></li>
</ol>
<blockquote>
<p>100G的文件给我们的感觉是太大，我们的电脑内存一般都为4G左右所以不可能一次性把这么多的信息都加载到内存，所以就要进行切分成100份。IP地址是字符串太长，我们可以把它转化为整型%100，这样取模后的值都落在0-99的区间里，所取模后值相同的IP地址都被分配到同一个文件，这时我们就可以采用哈希表统计出每个文件中最多的那个IP地址，最后比较得到100个IP中最大的那个IP就可以了 。</p>
</blockquote>
<ol start="28">
<li><strong>与上题条件相同，如何找到top K的IP？</strong></li>
</ol>
<blockquote>
<p>看到求TOP K个IP就要立马反应到使用堆排序，这里的堆排序应该注意的是要建一个小堆，想一下我们建大堆的话只能保证堆顶元素为最大的，这样只能得到最大的那个IP。</p>
</blockquote>
<ol start="29">
<li><p><strong>数据仓库存储一般选型Hive，HBase，Kudu三种，</strong></p>
<ol>
<li>请问选型的考量点是什么?</li>
<li>生产上数据仓库分层，由于数据延时，第二层第三层怎样更新?</li>
<li>对应计算指标如何更新?</li>
</ol>
</li>
<li><p><strong>RDD和普通集合的对比 </strong></p>
<blockquote>
<p>RDD里面计入的是描述信息（从哪里读取数据，以后对数据如何计算），</p>
<p>RDD的方法分为两类 Transformation(lazy)，Action(生成task，并发送到executor执行)。 </p>
<p>scala集合中存储的时真正要计算的数据、执行方法后立即返回结果。</p>
<p>一系列分区<br>每一个输入切片会有一个函数作用在上面<br>RDD之间存在依赖关系（是父RDD调用什么方法，传入那些函数得到的） </p>
<p>（可选）RDD中如果存储的是KV，shuﬄe是会有一个分区器，默认是hash partitioner</p>
<p>（可选) 如果读取的是HDFS数据，那么会有一个优位置。</p>
</blockquote>
</li>
<li><p>Scala柯里化</p>
</li>
<li><p>Scala隐式转换（spark的排序）</p>
</li>
<li><p>值传递和引用传递</p>
</li>
<li><p><strong>JVM的gc</strong></p>
<p>JAVA中有一套完整的对于回收堆内存的一个机制，被我们称为垃圾回收机制，也被称为GC。</p>
<p>在GC中有两个启动的方式，第一种是 System.gc 第二种是 系统自行判断是否进行清理</p>
</li>
<li><p>JVM内存模型</p>
</li>
<li><p>多线程获取线程结果</p>
</li>
<li><p>ArrayList、LinkList</p>
</li>
<li><p><strong>Spark宽窄依赖</strong></p>
<blockquote>
<p>宽依赖：指的是父RDD的分区可以被多个子RDD的分区所使用</p>
<p>窄依赖：指的是父RDD的分区最多只能被一个子RDD的分区所使用</p>
</blockquote>
</li>
<li><p><a href="https://www.cnblogs.com/qingyunzong/p/8955141.html" target="_blank" rel="noopener"><strong>Spark内存模型</strong></a></p>
</li>
<li><p><strong>sql 的行列互转</strong></p>
<blockquote>
</blockquote>
</li>
<li><p><strong>hive行列互转</strong></p>
<blockquote>
<ol>
<li><p>行转列</p>
<p>select id,</p>
<p>from table</p>
<p>lateral view explode( splect (列名，‘,‘’)) as 虚拟列名 ；</p>
</li>
<li><p>列转行</p>
<p>select id , </p>
<p>concat_ws( collect_set / collect_list ( 列名 )) as coumln</p>
<p>from table group by id ;</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>find 文件内容</strong></p>
<blockquote>
<p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># find . -name "*.c"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>将目前目录其其下子目录中所有一般文件列出</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># find . -type f</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># find . -ctime -20</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># find / -type f -size 0 -exec ls -l &#123;&#125; \;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>linux统计端口使用个数和列表</p>
</li>
<li><p>项目流程、数据量、数据倾斜、故障案例、高可靠设计、调优等等</p>
</li>
<li><p><strong>Hive中的排序关键字有哪些</strong></p>
<blockquote>
<p><strong>sort by :  </strong>order by ，cluster by ，distribute by<br><strong>sort by ：</strong>不是全局排序，其在数据进入reducer前完成排序<br><strong>order by ：</strong>会对输入做全局排序，因此只有一个reducer(多个reducer无法保证全局有序).只有一个<strong>reducer   :  </strong>会导致当输入规模较大时，需要较长的计算时间。<br><strong>cluster by ：</strong>当distribute by 和sort by的字段相同时，等同于cluster by.可以看做特殊的distribute + sort<br><strong>distribute by :</strong> 按照指定的字段对数据进行划分输出到不同的reduce中</p>
</blockquote>
</li>
<li><p><strong>Kafka如何保证消息不丢失，不重复</strong></p>
<blockquote>
<p><strong>数据不重复：</strong></p>
<pre><code>**使用的是exactly-once策略**
生产者和消费者都可以使用这种策略
1、幂等：他内部对数据进行了标识（具体怎么标识的不清楚），保证数据结果只收到一次，就是生产者只接收完整数据并存储一次，消费者也是只接收一次完整结果。
2、事务：对于生产者来说，就是客户端和接收端之间建立事务，通过事务对接，如果有一方出现错误情况则数据全部回滚重新写入，直到成功为止
    对于消费者来说，就是消费数据和偏移量之间建立事务，通过事务的对接，如果有一方出现错误情况则数据全部回滚重新写入，直到消费数据和偏移量保持一致，则保证数据消费成功
</code></pre></blockquote>
<blockquote>
<p><strong>不丢失：</strong></p>
<pre><code>**生产者：ACK机制**
ack机制：broker表示发来的数据已确认接收无误，表示数据已经保存到磁盘。
0：不等待broker返回确认消息
1：等待topic中某个partition leader保存成功的状态反馈
-1：等待topic中某个partition 所有副本都保存成功的状态反馈
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ack机制是对于Producer生产数据到kafka消息队列的一个机制</span><br><span class="line">&gt; 当返回0的时候，是我们生产完数据到broker，不做任何等待就直接确认</span><br><span class="line">&gt; 当返回1的时候，是数据生产到leader的kafka消息队列完成后，返回成功的状态（1）</span><br><span class="line">&gt; 当返回-1的时候，是数据生产到leader和follower节点副本备份全部都完成之后，再返回成功状态（all）</span><br><span class="line">&gt; 消费者：</span><br><span class="line">&gt; 	消费者对于数据不丢失就是对偏移量的维护，通过以上为了保证数据不丢失，我们可以将偏移量设置为数据消费完成后进行偏移量的更新。这样有可能存在数据重复消费的情况，所以我们可以通过上面所说的事务来保证数据不会重复消费的情况。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Spark中对于数组中的值进行排序  <em>Array((“ali”,6),(“baidu”,5),(“Ten”,8))</em></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getName).setMaster(<span class="string">"local[*]"</span>))</span><br><span class="line">  <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>((<span class="string">"ali"</span>,<span class="number">6</span>),(<span class="string">"baidu"</span>,<span class="number">5</span>),(<span class="string">"Ten"</span>,<span class="number">8</span>)))</span><br><span class="line">  rdd.map(x =&gt; (x._1,x._2).swap).sortByKey(<span class="literal">false</span>,<span class="number">1</span>).foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>result：</p>
<p>(8,Ten)<br>(6,ali)<br>(5,baidu)</p>
</li>
</ol>
<p>[^1]: On-Line Transaction Processing<a href="https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86" target="_blank" rel="noopener">联机事务处理</a>过程(OLTP)也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。<br>[^2]: 联机分析处理 (OLAP) , OLAP的目标是满足决策支持或者满足在多维环境下特定的查询和报表需求,它的技术核心是”维”这个概念。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Code/" rel="tag"># Code</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/27/浅谈什么是递归/" rel="next" title="浅谈什么是递归">
                <i class="fa fa-chevron-left"></i> 浅谈什么是递归
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/26/WL面试/" rel="prev" title="WL面试">
                WL面试 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">yimting@aliyun.com</p>
              <div class="site-description motion-element" itemprop="description">路漫漫其修远兮</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:yimting@aliyun.com" title="E-Mail &rarr; mailto:yimting@aliyun.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yimting@aliyun.com</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
